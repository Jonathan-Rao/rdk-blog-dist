<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>初级前端快速转TypeScript指南 | DK Rao&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.21b825ed.css" as="style"><link rel="preload" href="/assets/js/app.63f7405e.js" as="script"><link rel="preload" href="/assets/js/3.4c003ae3.js" as="script"><link rel="preload" href="/assets/js/2.1e9afdb9.js" as="script"><link rel="preload" href="/assets/js/70.fdb34293.js" as="script"><link rel="prefetch" href="/assets/js/1.dc850e31.js"><link rel="prefetch" href="/assets/js/10.5dbbc478.js"><link rel="prefetch" href="/assets/js/100.ff19186b.js"><link rel="prefetch" href="/assets/js/11.87e57194.js"><link rel="prefetch" href="/assets/js/12.4eece6bb.js"><link rel="prefetch" href="/assets/js/13.da88bff8.js"><link rel="prefetch" href="/assets/js/14.617fcb0e.js"><link rel="prefetch" href="/assets/js/15.e90ab816.js"><link rel="prefetch" href="/assets/js/16.217bdacc.js"><link rel="prefetch" href="/assets/js/17.2d36de58.js"><link rel="prefetch" href="/assets/js/18.09321884.js"><link rel="prefetch" href="/assets/js/19.b6545d31.js"><link rel="prefetch" href="/assets/js/20.3c7ccd65.js"><link rel="prefetch" href="/assets/js/21.9f3d9714.js"><link rel="prefetch" href="/assets/js/22.5bcf33e5.js"><link rel="prefetch" href="/assets/js/23.137a28d3.js"><link rel="prefetch" href="/assets/js/24.e9647410.js"><link rel="prefetch" href="/assets/js/25.e2f58923.js"><link rel="prefetch" href="/assets/js/26.dd88bede.js"><link rel="prefetch" href="/assets/js/27.3fa321d4.js"><link rel="prefetch" href="/assets/js/28.ef3548f7.js"><link rel="prefetch" href="/assets/js/29.9d932b65.js"><link rel="prefetch" href="/assets/js/30.3b1344cb.js"><link rel="prefetch" href="/assets/js/31.adb9ef94.js"><link rel="prefetch" href="/assets/js/32.ba3b310d.js"><link rel="prefetch" href="/assets/js/33.490aec31.js"><link rel="prefetch" href="/assets/js/34.3af32dbe.js"><link rel="prefetch" href="/assets/js/35.7ba2c423.js"><link rel="prefetch" href="/assets/js/36.45188d46.js"><link rel="prefetch" href="/assets/js/37.5aa1785c.js"><link rel="prefetch" href="/assets/js/38.2067f88b.js"><link rel="prefetch" href="/assets/js/39.f3777001.js"><link rel="prefetch" href="/assets/js/4.5cdec1e0.js"><link rel="prefetch" href="/assets/js/40.3e57f79d.js"><link rel="prefetch" href="/assets/js/41.6bab86e5.js"><link rel="prefetch" href="/assets/js/42.fc5c7ffb.js"><link rel="prefetch" href="/assets/js/43.882f3619.js"><link rel="prefetch" href="/assets/js/44.e0b4829e.js"><link rel="prefetch" href="/assets/js/45.9a8f29b4.js"><link rel="prefetch" href="/assets/js/46.e135ca80.js"><link rel="prefetch" href="/assets/js/47.a6036de5.js"><link rel="prefetch" href="/assets/js/48.d29a02a9.js"><link rel="prefetch" href="/assets/js/49.c7bc2bd4.js"><link rel="prefetch" href="/assets/js/5.250cdbf8.js"><link rel="prefetch" href="/assets/js/50.0b7f4d01.js"><link rel="prefetch" href="/assets/js/51.75cd77c1.js"><link rel="prefetch" href="/assets/js/52.9a8580a8.js"><link rel="prefetch" href="/assets/js/53.2c4a3f34.js"><link rel="prefetch" href="/assets/js/54.b5925329.js"><link rel="prefetch" href="/assets/js/55.9d030f6c.js"><link rel="prefetch" href="/assets/js/56.e9c1d955.js"><link rel="prefetch" href="/assets/js/57.2f34925d.js"><link rel="prefetch" href="/assets/js/58.a4eadcb3.js"><link rel="prefetch" href="/assets/js/59.25be9a24.js"><link rel="prefetch" href="/assets/js/6.d5177ab6.js"><link rel="prefetch" href="/assets/js/60.3494f023.js"><link rel="prefetch" href="/assets/js/61.57c595c0.js"><link rel="prefetch" href="/assets/js/62.f4e3be21.js"><link rel="prefetch" href="/assets/js/63.e40fa3d1.js"><link rel="prefetch" href="/assets/js/64.1464c9e9.js"><link rel="prefetch" href="/assets/js/65.ff5a9bdd.js"><link rel="prefetch" href="/assets/js/66.846ce21f.js"><link rel="prefetch" href="/assets/js/67.e2b7bec3.js"><link rel="prefetch" href="/assets/js/68.60d17170.js"><link rel="prefetch" href="/assets/js/69.34618919.js"><link rel="prefetch" href="/assets/js/71.d9d201ba.js"><link rel="prefetch" href="/assets/js/72.3a1c785d.js"><link rel="prefetch" href="/assets/js/73.f3d321c0.js"><link rel="prefetch" href="/assets/js/74.5f33d37c.js"><link rel="prefetch" href="/assets/js/75.281ea73f.js"><link rel="prefetch" href="/assets/js/76.465addf6.js"><link rel="prefetch" href="/assets/js/77.2564b7e8.js"><link rel="prefetch" href="/assets/js/78.a52c2e87.js"><link rel="prefetch" href="/assets/js/79.51c74067.js"><link rel="prefetch" href="/assets/js/80.dc3de84a.js"><link rel="prefetch" href="/assets/js/81.349bec82.js"><link rel="prefetch" href="/assets/js/82.fe3d6458.js"><link rel="prefetch" href="/assets/js/83.fececd3e.js"><link rel="prefetch" href="/assets/js/84.8abd5704.js"><link rel="prefetch" href="/assets/js/85.86950311.js"><link rel="prefetch" href="/assets/js/86.16cb092f.js"><link rel="prefetch" href="/assets/js/87.3e01636c.js"><link rel="prefetch" href="/assets/js/88.028ffdcf.js"><link rel="prefetch" href="/assets/js/89.0d2a51fb.js"><link rel="prefetch" href="/assets/js/9.23dd9dc1.js"><link rel="prefetch" href="/assets/js/90.8a58543f.js"><link rel="prefetch" href="/assets/js/91.eee5d437.js"><link rel="prefetch" href="/assets/js/92.458b922a.js"><link rel="prefetch" href="/assets/js/93.49ce0fe6.js"><link rel="prefetch" href="/assets/js/94.85821361.js"><link rel="prefetch" href="/assets/js/95.046b0fb4.js"><link rel="prefetch" href="/assets/js/96.b56d2320.js"><link rel="prefetch" href="/assets/js/97.7c1df4c9.js"><link rel="prefetch" href="/assets/js/98.7a0e133c.js"><link rel="prefetch" href="/assets/js/99.db916e56.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.db27a015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.21b825ed.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/EB-logo.png" alt="DK Rao's Blog" class="logo"> <span class="site-name can-hide">DK Rao's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/Jonathan-Rao/rdk-blog-dist" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://Jonathan-Rao.github.io/picx-images-hosting/20251017/f2097d47b248127e.mguj2u7f.jpg"> <div class="blogger-info"><h3>DK Rao</h3> <span>前端界的前行者</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/Jonathan-Rao/rdk-blog-dist" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>初级前端快速转TypeScript指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b89f7b/#一、为什么要用typescript" class="sidebar-link">一、为什么要用TypeScript</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/b89f7b/#二、typescript优缺点" class="sidebar-link">二、TypeScript优缺点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#缺点" class="sidebar-link">缺点</a></li></ul></li><li><a href="/pages/b89f7b/#三、typescript运行流程及javascript代码运行流程" class="sidebar-link">三、TypeScript运行流程及JavaScript代码运行流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/b89f7b/#四、typescript和javascript区别" class="sidebar-link">四、TypeScript和JavaScript区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#类型绑定" class="sidebar-link">类型绑定</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#何时检查类型" class="sidebar-link">何时检查类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#何时报告错误" class="sidebar-link">何时报告错误</a></li></ul></li><li><a href="/pages/b89f7b/#五、typescript总共围绕两种模式展开" class="sidebar-link">五、TypeScript总共围绕两种模式展开</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#显式注解类型" class="sidebar-link">显式注解类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#推导类型" class="sidebar-link">推导类型</a></li></ul></li><li><a href="/pages/b89f7b/#六、安装typescript-运行" class="sidebar-link">六、安装TypeScript &amp;&amp; 运行</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#typescript" class="sidebar-link">typescript</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#ts-node" class="sidebar-link">ts-node</a></li></ul></li><li><a href="/pages/b89f7b/#七、基础知识" class="sidebar-link">七、基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_1-基础静态类型" class="sidebar-link">1\. 基础静态类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_2-对象静态类型" class="sidebar-link">2\. 对象静态类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_3-函数类型注解" class="sidebar-link">3\. 函数类型注解</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_4-元组tuple" class="sidebar-link">4\. 元组Tuple</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_5-枚举enum" class="sidebar-link">5\. 枚举Enum</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_5-接口interface" class="sidebar-link">5\. 接口Interface</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_6-type" class="sidebar-link">6\. Type</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_7-联合类型" class="sidebar-link">7\. 联合类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_8-交叉类型" class="sidebar-link">8\. 交叉类型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_9-泛型" class="sidebar-link">9\. 泛型</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_10-模块" class="sidebar-link">10\. 模块</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_11-class类" class="sidebar-link">11\. Class类</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_12-命名空间namespace" class="sidebar-link">12\. 命名空间namespace</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_13-tsconfig-json" class="sidebar-link">13\. tsConfig.json</a></li></ul></li><li><a href="/pages/b89f7b/#八、实用类型" class="sidebar-link">八、实用类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_1-exclude" class="sidebar-link">1\. Exclude</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_2-extract" class="sidebar-link">2\. Extract</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_3-readonly" class="sidebar-link">3\. Readonly</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_4-partial" class="sidebar-link">4\. Partial</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_5-pick" class="sidebar-link">5\. Pick</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_6-omit" class="sidebar-link">6\. Omit</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_7-required" class="sidebar-link">7\. Required</a></li><li class="sidebar-sub-header level3"><a href="/pages/b89f7b/#_8-record" class="sidebar-link">8\. Record</a></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><!----> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/Jonathan-Rao" target="_blank" title="作者" class="beLink" data-v-06225672>DK Rao</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-01-07</a></div> <div title="分类" class="date iconfont icon-wenjian" data-v-06225672><a href="/categories/?category=%E5%89%8D%E7%AB%AF" data-v-06225672>前端 </a></div></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">初级前端快速转TypeScript指南<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="一、为什么要用typescript"><a href="#一、为什么要用typescript" class="header-anchor">#</a> 一、为什么要用TypeScript</h2> <p><code>TypeScript</code>可以让我们开发中避免一些<code>类型</code>或者<code>一些不是我们预期希望的代码结果</code>错误。xxx is not defined 我们都知道<code>JavaScript</code>错误是在运行中才抛出的，但是<code>TypeScript</code>错误直接是在编辑器里告知我们的，这极大的提升了开发效率，也不用花大量的时间去写单测，同时也避免了大量的时间排查<code>Bug</code>。</p> <h2 id="二、typescript优缺点"><a href="#二、typescript优缺点" class="header-anchor">#</a> 二、TypeScript优缺点</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li><p>一般我们在前后端联调时，都要去看接口文档上的字段类型，而<code>TypeScript</code>会自动帮我们识别当前的类型。节省了我们去看<code>文档</code>或者<code>network</code>时间。这叫做类型推导(待会我们会讲到)</p></li> <li><p>友好地在编辑器里提示错误，避免代码在运行时类型隐式转换踩坑。</p></li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ul><li><p>有一定的学习成本，<code>TypeScript</code>中有几种类型概念，<code>interface接口</code>、<code>class类</code>、<code>enum枚举</code>、<code>generics泛型</code>等这些需要我们花时间学习。</p></li> <li><p>可能和一些插件库结合的不是很完美</p></li></ul> <h2 id="三、typescript运行流程及javascript代码运行流程"><a href="#三、typescript运行流程及javascript代码运行流程" class="header-anchor">#</a> 三、TypeScript运行流程及JavaScript代码运行流程</h2> <p>1. JavaScript运行流程如下，依赖NodeJs环境和浏览器环境</p> <ul><li>将<code>JavaScript</code>代码转换为<code>JavaScript-AST</code></li> <li>将<code>AST</code>代码转换为字节码</li> <li>运算时计算字节码</li></ul> <p>2. TypeScript运行流程，以下操作均为TSC操作，三步执行完继续同上操作，让浏览器解析</p> <ul><li>将<code>TypeScript</code>代码编译为 <code>TypeScript-AST</code></li> <li>检查<code>AST</code>代码上类型检查</li> <li>类型检查后，编译为<code>JavaScript</code>代码</li> <li><code>JavaScript</code>代码转换为<code>JavaScript-AST</code></li> <li>将<code>AST</code>代码转换为字节码</li> <li>运算时计算字节码</li></ul> <h2 id="四、typescript和javascript区别"><a href="#四、typescript和javascript区别" class="header-anchor">#</a> 四、TypeScript和JavaScript区别</h2> <p>只有搞懂了二者的区别，我们才可以更好的理解<code>TypeScript</code></p> <table><thead><tr><th>类型系统特性</th> <th>JavaScript</th> <th>TypeScript</th></tr></thead> <tbody><tr><td>类型是如何绑定？</td> <td>动态</td> <td>静态</td></tr> <tr><td>是否存在类型隐式转换？</td> <td>是</td> <td>否</td></tr> <tr><td>何时检查类型？</td> <td>运行时</td> <td>编译时</td></tr> <tr><td>何时报告错误</td> <td>运行时</td> <td>编译时</td></tr></tbody></table> <h3 id="类型绑定"><a href="#类型绑定" class="header-anchor">#</a> 类型绑定</h3> <p>JavaScript</p> <p><code>JavaScript</code>动态绑定类型，只有运行程序才能知道类型，在程序运行之前<code>JavaScript</code>对类型一无所知</p> <p>TypeScript</p> <p><code>TypeScript</code>是在程序运行前（也就是编译时）就会知道当前是什么类型。当然如果该变量没有定义类型，那么<code>TypeScript</code>会自动类型推导出来。</p> <h3 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h3> <p>JavaScript</p> <p>比如在<code>JavaScript</code>中<code>1 + true</code>这样一个代码片段，<code>JavaScript</code>存在隐式转换，这时<code>true</code>会变成<code>number</code>类型<code>number(true)</code>和1相加。</p> <p>TypeScript</p> <p>在<code>TypeScript</code>中，<code>1+true</code>这样的代码会在<code>TypeScript</code>中报错，提示<code>number</code>类型不能和<code>boolean</code>类型进行运算。</p> <h3 id="何时检查类型"><a href="#何时检查类型" class="header-anchor">#</a> 何时检查类型</h3> <p>JavaScript</p> <p>在<code>JavaScript</code>中只有在程序运行时才能检查类型。类型也会存在隐式转换，很坑。</p> <p>TypeScript</p> <p>在<code>TypeScript</code>中，在编译时就会检查类型，如果和预期的类型不符合直接会在编辑器里报错、爆红</p> <h3 id="何时报告错误"><a href="#何时报告错误" class="header-anchor">#</a> 何时报告错误</h3> <p>JavaScript</p> <p>在<code>JavaScript</code>只有在程序执行时才能抛出异常，<code>JavaScript</code>存在隐式转换，等我们程序执行时才能真正的知道代码类型是否是预期的类型，代码是不是有效。</p> <p>TypeScript</p> <p>在<code>TypeScript中</code>，当你在编辑器写代码时，如有错误则会直接抛出异常，极大得提高了效率，也是方便。</p> <h2 id="五、typescript总共围绕两种模式展开"><a href="#五、typescript总共围绕两种模式展开" class="header-anchor">#</a> 五、TypeScript总共围绕两种模式展开</h2> <h3 id="显式注解类型"><a href="#显式注解类型" class="header-anchor">#</a> 显式注解类型</h3> <p>举个栗子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let name: string = &quot;前端娱乐圈&quot;;

let age: number = 38;

let hobby: string[] = [&quot;write code&quot;, &quot;玩游戏&quot;]
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>显式注解类型就是，声明变量时定义上类型（官方话语就是声明时带上注解），让我们一看就明白，哦~，这个<code>name</code>是一个<code>string</code>类型。</p> <h3 id="推导类型"><a href="#推导类型" class="header-anchor">#</a> 推导类型</h3> <p>举个栗子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let name = &quot;前端娱乐圈&quot;; // 是一个string类型

let age = 38;  // 是一个number类型

let hobby = [&quot;write code&quot;, &quot;玩游戏&quot;] // 是一个string数组类型
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>推导类型就是去掉显示注解，系统自动会识别当前值是一个什么类型的。</p> <h2 id="六、安装typescript-运行"><a href="#六、安装typescript-运行" class="header-anchor">#</a> 六、安装TypeScript &amp;&amp; 运行</h2> <h3 id="typescript"><a href="#typescript" class="header-anchor">#</a> typescript</h3> <p>全局安装<code>typescript</code>环境。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm i -g typescript
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可是这只是安装了<code>typescript</code>，那我们怎么运行<code>.ts</code>文件呢，安装完<code>typescript</code>我们就可以执行<code>tsc</code>命令。</p> <p>如：我们的文件叫做<code>index.ts</code>，直接在命令行执行<code>tsc index.ts</code>即可。然后就可以看到在目录下编译出来一个<code>index.js</code>，这就是<code>tsc</code>编译完的结果。</p> <p>index.ts</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const userName: string = &quot;前端娱乐圈&quot;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>运行<code>tsc index.ts</code>，你可以看见在<code>index.ts</code>的同级下又生成一个<code>index.js</code>，如下就是编译的结果文件<code>index.js</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var userName = &quot;前端娱乐圈&quot;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面我们知道了运行<code>tsc</code>命令就可以编译生成一个文件，有的小伙伴觉得这样太麻烦了，每次运行只是编译出来一个文件还不是运行，还得用<code>node index.js</code>才可以运行。不急我们接着往下看</p> <h3 id="ts-node"><a href="#ts-node" class="header-anchor">#</a> ts-node</h3> <p>我们来看一下这个插件<code>ts-node</code>，这个插件可以直接运行<code>.ts</code>文件，并且也不会编译出来<code>.js</code>文件。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm i ts-node

// 运行 ts-node index.ts
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>讲到这里我们了解了为什么要用TypeScript和它的优缺点以及它的运行工作方式。</p> <p>那么接下来步入<code>TypeScript</code>基础知识的海洋啦~，follow me。</p> <p>感觉有帮助的小伙伴可以关注一下：前端娱乐圈 公众号，谢谢啦~，每天更新一篇小技巧</p> <h2 id="七、基础知识"><a href="#七、基础知识" class="header-anchor">#</a> 七、基础知识</h2> <h3 id="_1-基础静态类型"><a href="#_1-基础静态类型" class="header-anchor">#</a> 1. 基础静态类型</h3> <p>在<code>TypeScript</code>中基础类型跟我们<code>JavScript</code>中基础类型是一样的。只是有各别是<code>Ts</code>里面新出的。</p> <h4 id="_1-number"><a href="#_1-number" class="header-anchor">#</a> 1. number</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const count: number = 18; // 显示注解一个number类型

const count1 = 18; // 不显示注解，ts会自动推导出来类型

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_2-string"><a href="#_2-string" class="header-anchor">#</a> 2. string</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const str: string = &quot;前端娱乐圈&quot;; // 显示注解一个string类型

const str1 = &quot;蛙人&quot;; // 不显示注解，ts会自动推导出来类型
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3-boolean"><a href="#_3-boolean" class="header-anchor">#</a> 3. boolean</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const status: string = false; // 显示注解一个string类型

const status1 = true; // 不显示注解，ts会自动推导出来类型
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_4-null"><a href="#_4-null" class="header-anchor">#</a> 4. null</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const value: null = null;

const value: null = undefined; // 这一点null类型可以赋值undefined跟在 js中是一样的，null == undefined
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_5-undefined"><a href="#_5-undefined" class="header-anchor">#</a> 5. undefined</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const value: undefined = undefined;

const value: undefined = null; // 这一点null类型可以赋值undefined跟在 js中是一样的，null == undefined
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_6-void"><a href="#_6-void" class="header-anchor">#</a> 6. void</h4> <p>估计到这有一些小伙伴可能对<code>void</code>这个比较陌生，以为只有<code>TypeScript</code>才有的。其实不是哈，在我们<code>JavaScript</code>就已经存在<code>void</code>关键字啦，它的意思就是无效的，有的小伙伴可能看见过早些项目里面<code>&lt;a href=&quot;javascript: void(0)&quot;&gt;</code>这是控制<code>a</code>标签的跳转默认行为。你不管怎么执行<code>void</code>方法它都是返回<code>undefined</code></p> <p>那么在我们<code>TypeScript</code>中<code>void</code>类型是什么呢。它也是代表无效的，一般只用在函数上，告诉别人这个函数没有返回值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function fn(): void {} // 正确

function testFn(): void {
    return 1; // 报错，不接受返回值存在
}

function fn1(): void { return undefined} // 显示返回undefined类型，也是可以的

function fn2(): void { return null} // 显示返回null类型也可以，因为 null == undefined
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_7-never"><a href="#_7-never" class="header-anchor">#</a> 7. never</h4> <p><code>never</code>一个永远不会有值的类型或者也可以说一个永远也执行不完的类型，代表用于不会有值，<code>undefined</code>、<code>null</code>也算做是值。一般这个类型就不会用到，也不用。大家知道这个类型就行。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const test: never = null; // 错误
const test1: never = undefined // 错误

function Person(): never { // 正确，因为死循环了，一直执行不完
    while(true) {}
}

function Person(): never { // 正确，因为递归，永远没有出口
    Person()
}

function Person(): never { // 正确 代码报错了，执行不下去
    throw new Error()
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="_8-any"><a href="#_8-any" class="header-anchor">#</a> 8. any</h4> <p><code>any</code>这个类型代表任何的、任意的。希望大家在项目中，不要大片定义<code>any</code>类型。虽然它真的好使，那这样我们写<code>TypeScript</code>就没有任何意义了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let value: any = &quot;&quot;; // 正确
value = null // 正确
value = {} // 正确
value = undefined // 正确
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_9-unknown"><a href="#_9-unknown" class="header-anchor">#</a> 9. unknown</h4> <p><code>unknown</code>类型是我们<code>TypeScript</code>中第二个<code>any</code>类型，也是接受任意的类型的值。它的英文翻译过来就是未知的，我们来看一下栗子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let value: unknown = &quot;&quot;	
value = 1;
value = &quot;fdsfs&quot;
value = null
value = {}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>那现在肯定有小伙伴疑惑，诶，那它<code>unknown</code>相当于是<code>any</code>类型，那二者的区别是什么。我们来看一下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let valueAny: any = &quot;&quot;;
let valueUnknown: unknown = &quot;&quot;;

valueAny = &quot;蛙人&quot;;
valueUnknown = &quot;前端娱乐圈&quot;

let status: null = false;
status = valueAny; // 正确
status = valueUnknown // 报错，不能将unknown类型分配给null类型
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们来看一下上面的，为什么<code>any</code>类型就能被赋值成功，而<code>unknown</code>类型不行呢，从它俩的意义来上看，还是有点区别的，<code>any</code>任何的，任意的、<code>unknown</code>未知的。所以你给<code>unknown</code>类型赋值任何类型都没关系，因为它本来就是未知类型嘛。但是你如果把它的<code>unknown</code>类型去被赋值一个<code>null</code>类型，这时人家<code>null</code>这边不干了，我不接受<code>unknown</code>类型。</p> <p>说白了一句话，别人不接受<code>unknown</code>类型，而<code>unknown</code>类型接受别人，哈哈哈哈。</p> <h3 id="_2-对象静态类型"><a href="#_2-对象静态类型" class="header-anchor">#</a> 2. 对象静态类型</h3> <p>说起对象类型，我们肯定都能想到对象包含<code>{}</code>、<code>数组</code>、<code>类</code>、<code>函数</code></p> <h4 id="_1-object"><a href="#_1-object" class="header-anchor">#</a> 1. object &amp;&amp; {}</h4> <p>其实这俩意思一样，<code>{}</code>、<code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const list: object = {} // 空对象

const list1: object = null; // null对象

const list: object = [] // 数组对象

const list: {} = {}
list.name = 1 // 报错 不可更改里面的字段，但是可以读取
list.toString()
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="_2-数组"><a href="#_2-数组" class="header-anchor">#</a> 2. 数组</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const list: [] = []; // 定义一个数组类型

const list1: number[] = [1,2] // 定义一个数组，里面值必须是number

const list2: object[] = [null, {}, []] // 定义一个数组里面必须是对象类型的

const list3: Array&lt;number&gt; = [1,2,3] // 泛型定义数组必须是number类型，泛型我们待会讲到
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_3-类"><a href="#_3-类" class="header-anchor">#</a> 3. 类</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 类
class ClassPerson = {
    name: &quot;前端娱乐圈&quot;
}

const person: ClassPerson = new Person();
person.xxx = 123; // 这行代码报错，因为当前类中不存在该xxx属性
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_4-函数"><a href="#_4-函数" class="header-anchor">#</a> 4. 函数</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 函数
const fn: () =&gt; string = () =&gt; &quot;前端娱乐圈&quot; // 定义一个变量必须是函数类型的，返回值必须是string类型
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-函数类型注解"><a href="#_3-函数类型注解" class="header-anchor">#</a> 3. 函数类型注解</h3> <p>这里说一下函数显示注解和函数参数不会类型推导问题。</p> <h4 id="_1-函数返回类型为number"><a href="#_1-函数返回类型为number" class="header-anchor">#</a> 1. 函数返回类型为number</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function fn(a, b): number {
    return a + b;
}
fn(1, 2)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_2-函数void"><a href="#_2-函数void" class="header-anchor">#</a> 2. 函数void</h4> <p>显示注解为<code>void</code>类型，函数没有返回值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function fn(): void {
    console.log(1)
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3-函数不会自动类型推导"><a href="#_3-函数不会自动类型推导" class="header-anchor">#</a> 3. 函数不会自动类型推导</h4> <p>可以看到下面的函数类型，不会自动类型推导，我们实参虽然传入的1和2，但是形参方面是可以接受任意类型值的，所以系统也识别不出来你传递的什么，所以这里得需要我们显示定义注解类型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function testFnQ(a, b) {
    return a + b
}
testFnQ(1,2)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e22b46ebd9244b9fa9c7158a35911826~tplv-k3u1fbpfcp-watermark.awebp" alt="微信截图_20210824233905.png"></p> <p>我们来改造一下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function testFnQ(a:number, b:number) {
    return a + b
}
testFnQ(1,2)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1ca8dd6aff646e7b80c53518fdf28c1~tplv-k3u1fbpfcp-watermark.awebp" alt="微信截图_20210825001425.png"></p> <p>我们再来看一下参数对象显示注解类型，也是在<code>:</code>号后面赋值每个字段类型即可。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function testFnQ(obj : {num: number}) {
    return obj.num
}
testFnQ({num: 18})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-元组tuple"><a href="#_4-元组tuple" class="header-anchor">#</a> 4. 元组Tuple</h3> <p>元组用于表示一个已知数组的数量和类型的数组，定义数组中每一个值的类型，一般不经常使用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr: [string, number] = [&quot;前端娱乐圈&quot;, 1]

const arr: [string, string] = [&quot;前端娱乐圈&quot;, 1] // 报错
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_5-枚举enum"><a href="#_5-枚举enum" class="header-anchor">#</a> 5. 枚举Enum</h3> <p><code>Enum</code>枚举类型，可以设置默认值，如果不设置则为索引。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>enum color {
    RED,
    BLUE = &quot;blue&quot;,
    GREEN = &quot;green&quot;
}

// color[&quot;RED&quot;] 0
// color[&quot;BLUE&quot;] blue

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>像上面的<code>color</code>中<code>RED没</code>有设置值，那么它的值则为<code>0</code>，如果<code>BLUE</code>也不设置的话那么它的值则是<code>1</code>，它们这里是递增。如果设置值则是返回设置的值</p> <p>注意这里还有一个问题，直接来上代码</p> <p>通过上面学习我们知道了<code>enum</code>可以递增值，也可以设置默认值。但是有一点得注意一下，<code>enum</code>没有<code>json</code>对象那样灵活，<code>enum</code>不能在任意字段上设置默认值。</p> <p>比如下面栗子，<code>RED</code>没有设置值，然后<code>BLUE</code>设置了默认值，但是<code>GREEN</code>又没有设置，这时这个<code>GREEN</code>会报错。因为你第二个<code>BLUE</code>设置完默认值，第三又不设置，这时代码都不知道该咋递增了，所以报错。还有一种方案就是你给<code>BLUE</code>可以设置一个数字值，这时第三个<code>GREEN</code>不设置也会跟着递增，因为都是<code>number</code>类型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 报错
enum color {
    RED,
    BLUE = &quot;blue&quot;,
    GREEN
}

// good
enum color {
    RED,	   // 0
    BLUE = 4,  // 4
    GREEN      // 5
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>比如<code>enum</code>枚举类型还可以反差，通过<code>value</code>查<code>key</code>值。像我们<code>json</code>对象就是不支持这种写法的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>enum color {
    RED,	   // 0
    BLUE = 4,  // 4
    GREEN      // 5
}

console.log(color[4]) // BLUE
console.log(color[0]) // RED
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_5-接口interface"><a href="#_5-接口interface" class="header-anchor">#</a> 5. 接口Interface</h3> <p>接口<code>interface</code>是什么，接口<code>interface</code>就是方便我们定义一处代码，多处复用。接口里面也存在一些修饰符。下面我们来认识一下它们吧。</p> <h4 id="_1-接口怎么复用"><a href="#_1-接口怎么复用" class="header-anchor">#</a> 1. 接口怎么复用</h4> <p>比如在讲到这之前，我们不知道<code>接口</code>这东西，可能需要给对象定义一个类型的话，你可能会这样做。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const testObj: { name: string, age: number } = { name: &quot;前端娱乐圈&quot;, age: 18 }

const testObj1: { name: string, age: number } = { name: &quot;蛙人&quot;, age: 18 }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们用接口来改造一下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    name: string,
    age: number
}

const testObj: Types = { name: &quot;前端娱乐圈&quot;, age: 18 }

const testObj1: Types = { name: &quot;蛙人&quot;, age: 18 }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到使用<code>interface</code>关键字定义一个接口，然后赋值给这两个变量，实现复用。</p> <h4 id="_2-readonly修饰符"><a href="#_2-readonly修饰符" class="header-anchor">#</a> 2. readonly修饰符</h4> <p><code>readonly</code>类型，只可读状态，不可更改。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    readonly name: string,
    readonly age: number
}

const testObj: Types = { name: &quot;前端娱乐圈&quot;, age: 18 }

const testObj1: Types = { name: &quot;蛙人&quot;, age: 18 }

testObj.name = &quot;张三&quot; // 无法更改name属性，因为它是只读属性
testObj1.name = &quot;李四&quot; // 无法更改name属性，因为它是只读属性
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_3-可选修饰符"><a href="#_3-可选修饰符" class="header-anchor">#</a> 3. ?可选修饰符</h4> <p>可选修饰符以<code>?</code>定义，为什么需要可选修饰符呢，因为如果我们不写<code>可选修饰符</code>，那<code>interface</code>里面的属性都是必填的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    readonly name: string,
    readonly age: number,
    sex?: string
}

const testObj: Types = { name: &quot;前端娱乐圈&quot;, age: 18}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_4-extends继承"><a href="#_4-extends继承" class="header-anchor">#</a> 4. extends继承</h4> <p>我们的<code>interface</code>也是可以继承的，跟ES6<code>Class</code>类一样，使用<code>extends</code>关键字。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    readonly name: string,
    readonly age: number,
    sex?: string
}

interface ChildrenType extends Types { // 这ChildrenType接口就已经继承了父级Types接口
    hobby: []
}

const testObj: ChildrenType = { name: &quot;前端娱乐圈&quot;, age: 18， hobby: [&quot;code&quot;, &quot;羽毛球&quot;] }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_5-propname扩展"><a href="#_5-propname扩展" class="header-anchor">#</a> 5. propName扩展</h4> <p>interface里面这个功能就很强大，它可以写入不在interface里面的属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    readonly name: string,
    readonly age: number,
    sex?: string,
}

const testObj: Types = { name: &quot;前端娱乐圈&quot;, age: 19, hobby: [] }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面这个<code>testObj</code>这行代码会爆红，因为<code>hobby</code>属性不存在<code>interface</code>接口中，那么我们不存在的接口中的，还不让人家写了？。这时候可以使用自定义就是上面的<code>propName</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types {
    readonly name: string,
    readonly age: number,
    sex?: string,
    [propName: string]: any // propName字段必须是 string类型 or number类型。 值是any类型，也就是任意的
}

const testObj: Types = { name: &quot;前端娱乐圈&quot;, age: 19, hobby: [] }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在运行上面代码，就可以看到不爆红了~</p> <h3 id="_6-type"><a href="#_6-type" class="header-anchor">#</a> 6. Type</h3> <p>我们再来看一下<code>Type</code>，这个是声明类型别名使的，别名类型只能定义是：<code>基础静态类型</code>、<code>对象静态类型</code>、<code>元组</code>、<code>联合类型</code>。</p> <blockquote><p>注意：type别名不可以定义interface</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>type Types = string;

type TypeUnite = string | number

const name: typeUnite = &quot;前端娱乐圈&quot;
const age: typeUnite = 18
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_1-那么type类型别名和interface接口有什么区别呢"><a href="#_1-那么type类型别名和interface接口有什么区别呢" class="header-anchor">#</a> 1. 那么type类型别名和interface接口有什么区别呢</h4> <h5 id="_1-type不支持interface声明"><a href="#_1-type不支持interface声明" class="header-anchor">#</a> 1. type不支持interface声明</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>type Types = number
type Types = string // 报错， 类型别名type不允许出现重复名字

interface Types1 {
    name: string
}

interface Types1 {
    age: number
}

// interface接口可以出现重复类型名称，如果重复出现则是，合并起来也就是变成 { name：string, age: number }
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>第一个<code>Types</code>类型别名type不允许出现重复名字，interface接口可以出现重复类型名称，如果重复出现则是，合并起来也就是变 <code>{ name：string, age: number }</code></p> <p>再来看一下interface另一种情况</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Types1 {
    name: string
}

interface Types1 {
    name: number
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以看到上面两个同名称的<code>interface</code>接口，里面的属性也是同名称，但是类型不一样。这第二个的<code>Types1</code>就会爆红，提示：后续声明的接口，必须跟前面声明的同名属性类型必须保持一致，把后续声明的<code>name</code>它类型换成<code>string</code>即可。</p> <h5 id="_2-type支持表达式-interface不支持"><a href="#_2-type支持表达式-interface不支持" class="header-anchor">#</a> 2. type支持表达式 interface不支持</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>const count: number = 123
type testType = typeof count

const count: number = 123

interface testType {
    [name: typeof count]: any // 报错
}

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到上面<code>type</code>支持表达式，而<code>interface</code>不支持</p> <h5 id="_3-type-支持类型映射-interface不支持"><a href="#_3-type-支持类型映射-interface不支持" class="header-anchor">#</a> 3. type 支持类型映射，interface不支持</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>type keys = &quot;name&quot; | &quot;age&quot;
type KeysObj = {
    [propName in keys]: string
}

const PersonObj: KeysObj = { // 正常运行
    name: &quot;蛙人&quot;,
    age: &quot;18&quot;
}

interface testType {
    [propName in keys]: string // 报错
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_7-联合类型"><a href="#_7-联合类型" class="header-anchor">#</a> 7. 联合类型</h3> <p><code>联合类型</code>用<code>|</code>表示，说白了就是满足其中的一个<code>类型</code>就可以。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const statusTest: string | number = &quot;前端娱乐圈&quot;

const flag: boolean | number = true
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>再来看一下栗子。我们用函数参数使用联合类型看看会发生什么</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function testStatusFn(params: number | string) {
    console.log(params.toFixed()) // 报错
}

testStatusFn(1)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面我们说过了，函数参数类型不能类型自动推导，更何况现在用上联合类型，系统更懵逼了，不能识别当前实参的类型。所以访问当前类型上的方法报错。</p> <p>接下来带大家看一些<code>类型保护</code>，听着挺高级，其实这些大家都见过。别忘了记得关注：前端娱乐圈 公众号哦，嘻嘻</p> <h4 id="_1-typeof"><a href="#_1-typeof" class="header-anchor">#</a> 1. typeof</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function testStatusFn(params: number | string) {
    console.log(params.toFixed()) // 报错
}
testStatusFn(1)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>改造后</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 正常
function testStatusFn(params: string | number) {
    if (typeof params == &quot;string&quot;) {
        console.log(params.split)
    }

    if (typeof params == &quot;number&quot;) {
        console.log(params.toFixed)
    }
}

testStatusFn(1)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_2-in"><a href="#_2-in" class="header-anchor">#</a> 2. in</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 报错
interface frontEnd {
    name: string
}

interface backEnd {
    age: string
}

function testStatusFn(params: frontEnd | backEnd) {
    console.log(params.name)
}

testStatusFn({name: &quot;蛙人&quot;})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>改造后</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 正常
function testStatusFn(params: frontEnd | backEnd) {
    if (&quot;name&quot; in params) {
        console.log(params.name)
    }

    if (&quot;age&quot; in params) {
        console.log(params.age)
    }
}

testStatusFn({name: &quot;蛙人&quot;})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_3-as-断言"><a href="#_3-as-断言" class="header-anchor">#</a> 3. as 断言</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 报错
interface frontEnd {
    name: string
}

interface backEnd {
    age: string
}

function testStatusFn(params: frontEnd | backEnd) {
    console.log(params.name)
}

testStatusFn({name: &quot;蛙人&quot;})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>改造后</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 正常
function testStatusFn(params: frontEnd | backEnd) {
    if (&quot;name&quot; in params) {
        const res = (params as frontEnd).name
        console.log(res)
    }

    if (&quot;age&quot; in params) {
        const res = (params as backEnd).age
        console.log(res)
    }
}

testStatusFn({age: 118})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_8-交叉类型"><a href="#_8-交叉类型" class="header-anchor">#</a> 8. 交叉类型</h3> <p><code>交叉类型</code>就是跟联合类型相反，它用<code>&amp;</code>表示，<code>交叉类型</code>就是两个类型必须存在。这里还用上面的联合类型的栗子来看下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface frontEnd {
    name: string
}

interface backEnd {
    age: number
}

function testStatusFn(params: frontEnd &amp; backEnd) {}

testStatusFn({age: 118, name: &quot;前端娱乐圈&quot;})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里我们可以看到实参必须传入两个**接口(interface)**全部的属性值才可以。联合类型是传入其中类型就可以。</p> <p>注意：我们的接口interface出现同名属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface frontEnd {
    name: string
}

interface backEnd {
    name: number
}

function testStatusFn(params: frontEnd &amp; backEnd) {
    console.log(params)
}

testStatusFn({name: &quot;前端&quot;})
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>上面我们两个接口类型中都出现了同名属性，但是类型不一样，这时类型就会变为<code>never</code>。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51e337707b6641e590bbb0139fabacdb~tplv-k3u1fbpfcp-watermark.awebp" alt=""></p> <h3 id="_9-泛型"><a href="#_9-泛型" class="header-anchor">#</a> 9. 泛型</h3> <p>泛型是<code>TypeScript</code>中最难理解的了，这里我尽量用通俗易懂的方式讲明白。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function test(a: string | number, b: string | number) {
    console.log(a, b)
}
test(1, &quot;前端娱乐圈&quot;)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>比如上面栗子，函数参数<code>注解类型</code>定义<code>string</code>和<code>number</code>，调用函数实参传入也没什么问题，但是有个需求，就是实参我们必须传入同样的类型（传入两个<code>number</code>类型）。虽然上面这种联合类型也可以实现，但是如果我们要在加一个<code>boolean</code>类型，那么联合类型还得在追加一个<code>boolean</code>，那这样代码太冗余了。</p> <p>这时就需要用到泛型了，泛型是专门针对不确定的类型使用，并且灵活。泛型的使用大部分都是使用<code>&lt;T&gt;</code>，当然也可以随便使用，如：<code>&lt;Test&gt;</code>、<code>&lt;Custom&gt;</code>都可以。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function test&lt;T&gt;(a: T, b: T) {
    console.log(a, b)
}
test&lt;number&gt;(1, &quot;前端娱乐圈&quot;) // 调用后面跟着尖括号这就是泛型的类型，这时报错，因为在调用的使用类型是number，所以只能传入相同类型的

test&lt;boolean&gt;(true, false)

test&lt;string&gt;(&quot;前端娱乐圈&quot;, &quot;蛙人&quot;)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面这使用泛型就解决了我们刚才说的传入同一个类型参数问题，但是泛型也可以使用不同的参数，可以把调用类型定义为<code>&lt;any&gt;</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function test&lt;T&gt;(a: T, b: T) {
    console.log(a, b)
}

test&lt;any&gt;(1, &quot;前端娱乐圈&quot;)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>但是上面这种又有一种问题，它可以传入对象，但是如果我们只希望传入<code>number</code>类型和<code>string</code>类型。那么我们泛型也给我们提供了**<code>约束</code>类型。泛型使用<code>extends</code>进行了类型约束**，只能选择<code>string</code>、<code>number</code>类型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function test&lt;T extends number | string, Y extends number | string&gt;(a: T, b: Y) {
    console.log(a, b)
}

test&lt;number, string&gt;(18, &quot;前端娱乐圈&quot;)

test&lt;string, number&gt;(&quot;前端娱乐圈&quot;, 18)
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这时，传入泛型时使用<code>，</code>逗号分隔，来定义每一个类型希望是什么。记住，只有我们不确定的类型，可以使用泛型。</p> <h3 id="_10-模块"><a href="#_10-模块" class="header-anchor">#</a> 10. 模块</h3> <p><code>TypeScript</code>也支持<code>import</code>和<code>export</code>这里大多数小伙伴都知道，这里都不多讲啦。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 导入

import xxx, { xxx } from &quot;./xxx&quot;

// 导出

export default {}

export const name = &quot;前端娱乐圈&quot;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如有不明白的小伙伴，可以看我以前文章 <a href="https://juejin.cn/post/6938581764432461854" title="https://juejin.cn/post/6938581764432461854" target="_blank" rel="noopener noreferrer">聊聊什么是CommonJs和Es Module及它们的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_11-class类"><a href="#_11-class类" class="header-anchor">#</a> 11. Class类</h3> <blockquote><p>以下这三个修饰符是在<code>TypeScript</code>类中才能使用，在<code>JavaScript</code>类中是不支持的。</p></blockquote> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c70075650c78403f99887132bd93acd2~tplv-k3u1fbpfcp-watermark.awebp" alt="报错.png"></p> <h4 id="_1-public"><a href="#_1-public" class="header-anchor">#</a> 1. public</h4> <p><code>public</code>为<code>类</code>的公共属性，就是不管在<code>类</code>的内部还是外部，都可以访问该<code>类</code>中属性及方法。默认定义的属性及方法都是<code>public</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Person {
	name = &quot;前端娱乐圈&quot;;
	public age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 前端娱乐圈 18
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面可以看到打印结果都能显示出来，<code>name</code>属性没有定义<code>public</code>公共属性，所以<code>类</code>里面定义的属性及方法默认都是<code>public</code>定义。</p> <h4 id="_2-private"><a href="#_2-private" class="header-anchor">#</a> 2. private</h4> <p><code>private</code>为<code>类</code>的私有属性，只有在当前<code>类</code>里面才能访问，当前<code>类</code>就是<code>{}</code>里面区域内。在<code>{}</code>外面是不能访问<code>private</code>定义的属性及方法的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Person {
	private name = &quot;前端娱乐圈&quot;;
	private age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 这俩行会爆红，当前属性为私有属性，只能在类内部访问

class Scholl extends Person {
    getData() {
        return this.username + &quot;,&quot; + this.age
    }
}
const temp = new Scholl()
console.log(temp.getData()) // 爆红~，虽然继承了Person类，但是private定义是只能在当前类访问，子类也不能访问。
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="_3-protected"><a href="#_3-protected" class="header-anchor">#</a> 3. protected</h4> <p><code>protected</code>为<code>类</code>的保护属性，只有在当前类和子类可以访问。也就是说用<code>protected</code>属性定义的子类也可以访问。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Person {
    protected username = &quot;前端娱乐圈&quot;;
    protected age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 这俩行会爆红，当前属性为私有属性，只能在类内部访问

class Scholl extends Person {
    getData() {
        return this.username + &quot;,&quot; + this.age
    }
}
const temp = new Scholl()
console.log(temp.getData()) // 前端娱乐圈，18。可以正常访问父类的属性
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="_4-implements"><a href="#_4-implements" class="header-anchor">#</a> 4. implements</h4> <p><code>implements</code>关键字只能在<code>class</code>中使用，顾名思义，实现一个新的类，从父级或者从接口实现所有的属性和方法，如果在<code>PersonAll</code>类里面不写进去接口里面已有的属性和方法则会报错。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface frontEnd {
    name: string,
    fn: () =&gt; void
}

class PersonAll implements frontEnd {
    name: &quot;前端娱乐圈&quot;;

    fn() {

    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_5-抽象类"><a href="#_5-抽象类" class="header-anchor">#</a> 5. 抽象类</h4> <p>抽象类使用<code>abstract</code>关键字定义。<code>abstract</code>抽象方法不能实例化，如果，抽象类里面方法是抽象的，那么本身的类也必须是抽象的，抽象方法不能写函数体。父类里面有抽象方法，那么子类也必须要重新该方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 抽象类
abstract class Boss {
    name = &quot;秦&quot;;
    call() {} // 抽象方法不能写函数体
}

class A extends Boss {
    call() {
        console.log(this.name);
        console.log(&quot;A&quot;)
    }
}

class B extends Boss {
    call() {
         console.log(&quot;B&quot;)
    }
}

new A().call()
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>该抽象类使用场景，比如<code>A</code>需求或者<code>B</code>需求正好需要一个公共属性，然后本身还有一些自己的逻辑，就可以使用抽象类，抽象类只能在<code>TypeScript</code>中使用。</p> <h3 id="_12-命名空间namespace"><a href="#_12-命名空间namespace" class="header-anchor">#</a> 12. 命名空间namespace</h3> <p>我们学到现在可以看到，不知道小伙伴们发现没有，项目中文件是不是不能有重复的变量(不管你是不是一样的文件还是其它文件)，否则就直接爆红了。命名空间一个最明确的目的就是解决重名问题。</p> <p>命名空间使用<code>namespace</code>关键字来定义，来看栗子吧。</p> <p>index.ts</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>namespace SomeNameSpaceName {
    const q = {}

    export interface obj {
        name: string
    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面这样，就定义好了一个命名空间，可以看到变量<code>q</code>没有写<code>export</code>关键字，这证明它是内部的变量，就算别的<code>.ts</code>文件引用它，它也不会暴露出去。而<code>interface</code>这个<code>obj</code>接口是可以被全局访问的。</p> <p>我们在别的页面访问当前命名空间</p> <h4 id="_1-reference引入"><a href="#_1-reference引入" class="header-anchor">#</a> 1. reference引入</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>/// &lt;reference path=&quot;./index.ts&quot; /&gt;
namespace SomeNameSpaceName {
	export class person implements obj {
		name: &quot;前端娱乐圈&quot;
	}
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_2-import"><a href="#_2-import" class="header-anchor">#</a> 2. import</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>export interface valueData {
     name: string
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>import { valueData } from &quot;./xxx.ts&quot;
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这时使用命名空间之后完全可以解决不同文件重名爆红问题。</p> <h3 id="_13-tsconfig-json"><a href="#_13-tsconfig-json" class="header-anchor">#</a> 13. tsConfig.json</h3> <p>这个<code>tsconfig</code>文件，是我们编译ts文件，如何将<code>ts</code>文件编译成我们的<code>js</code>文件。<code>tsc -init</code>这个命令会生成该文件出来哈。执行完该命令，我们可以看到根目录下会生成一个<code>tsconfig.json</code>文件，里面有一堆属性。</p> <p>那么我们怎么将<code>ts</code>文件编译成<code>js</code>文件呢，直接执行<code>tsc</code>命令可以将根目录下所有的<code>.ts</code>文件全部编译成<code>.js</code>文件输出到项目下。</p> <p>更多配置文档，请参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.tslang.cn%2Fdocs%2Fhandbook%2Fcompiler-options.html" title="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    // include: [&quot;*.ts&quot;] // 执行目录下所有的ts文件转换成js文件
    // include: [&quot;index.ts&quot;] // 只将项目下index.ts文件转换为js文件
    // files: [&quot;index.ts&quot;] // 跟include一样，只执行当前数组值里面的文件,当前files必须写相对路径
    // exclude: [&quot;index.ts&quot;] // exclude就是除了index.ts不执行，其它都执行

    compilerOptions: {
        removeComments: true, // 去掉编译完js文件的注释
        outDir: &quot;./build&quot;, // 最终输出的js文件目录
        rootDir: &quot;./src&quot;, // ts入口文件查找
    }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="八、实用类型"><a href="#八、实用类型" class="header-anchor">#</a> 八、实用类型</h2> <p>最后来说一下实用类型，<code>TypeScript</code>标准库自带了一些实用类型。这些实用类都是方便接口<code>Interface</code>使用。这里只列举几个常用的，更多实用类型<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Futility-types.html" title="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_1-exclude"><a href="#_1-exclude" class="header-anchor">#</a> 1. Exclude</h3> <p>从一个类型中排除另一个类型，只能是联合类型，从<code>TypesTest</code>类型中排除<code>UtilityLast</code>类型。</p> <p>适用于：并集类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string
}

interface UtilityLast {
    age: number
}

type TypesTest = UtilityFirst | UtilityLast;

const ObjJson: Exclude&lt;TypesTest, UtilityLast&gt; = {
    name: &quot;前端娱乐圈&quot;
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_2-extract"><a href="#_2-extract" class="header-anchor">#</a> 2. Extract</h3> <p><code>Extract</code>正好跟上面那个相反，这是选择某一个可赋值的联合类型，从<code>TypesTest</code>类型中只选择<code>UtilityLast</code>类型。</p> <p>适用于：并集类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string
}

interface UtilityLast {
    age: number
}

type TypesTest = UtilityFirst | UtilityLast;

const ObjJson: Extract&lt;TypesTest, UtilityLast&gt; = {
    age: 1
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-readonly"><a href="#_3-readonly" class="header-anchor">#</a> 3. Readonly</h3> <p>把数组或对象的所有属性值转换为只读的。这里只演示一下对象栗子，数组同样的写法。</p> <p>适用于：对象、数组</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string
}

const ObjJson: Readonly&lt;UtilityFirst&gt; = {
    name: &quot;前端娱乐圈&quot;
}
ObjJson.name = &quot;蛙人&quot; // 报错 只读状态
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-partial"><a href="#_4-partial" class="header-anchor">#</a> 4. Partial</h3> <p>把对象的所有属性设置为选的。我们知道<code>interface</code>只要不设置<code>?</code>修饰符，那么对象都是必选的。这个实用类可以将属性全部转换为可选的。</p> <p>适用于：对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string
}

const ObjJson: Partial&lt;UtilityFirst&gt; = {

}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_5-pick"><a href="#_5-pick" class="header-anchor">#</a> 5. Pick</h3> <p><code>Pick</code>选择对象类型中的部分<code>key</code>值，提取出来。第一个参数<code>目标值</code>，第二个参数联合<code>key</code></p> <p>适用于：对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string,
    age: number,
    hobby: []
}

const ObjJson: Pick&lt;UtilityFirst, &quot;name&quot; | &quot;age&quot;&gt; = {
    name: &quot;前端娱乐圈&quot;,
    age: 18
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_6-omit"><a href="#_6-omit" class="header-anchor">#</a> 6. Omit</h3> <p><code>Omit</code>选择对象类型中的部分<code>key</code>值，过滤掉。第一个参数<code>目标值</code>，第二个参数联合<code>key</code></p> <p>适用于：对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name: string,
    age: number,
    hobby: string[]
}

const ObjJson: Pick&lt;UtilityFirst, &quot;name&quot; | &quot;age&quot;&gt; = {
    hobby: [&quot;code&quot;, &quot;羽毛球&quot;]
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_7-required"><a href="#_7-required" class="header-anchor">#</a> 7. Required</h3> <p><code>Required</code>把对象所有可选属性转换成必选属性。</p> <p>适用于：对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface UtilityFirst {
    name?: string,
    age?: number,
    hobby?: string[]
}

const ObjJson: Required&lt;UtilityFirst&gt; = {
    name: &quot;蛙人&quot;,
    age: 18,
    hobby: [&quot;code&quot;]
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_8-record"><a href="#_8-record" class="header-anchor">#</a> 8. Record</h3> <p>创建一个对象结果集，第一个参数则是<code>key</code>值，第二个参数则是<code>value</code>值。规定我们只能创建这里面字段值。</p> <p>适用于：对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>type IndexList = 0 | 1 | 2

const ObjJson: Record&lt;IndexList, &quot;前端娱乐圈&quot;&gt; = {
    0: &quot;前端娱乐圈&quot;,
    1: &quot;前端娱乐圈&quot;,
    2: &quot;前端娱乐圈&quot;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/Jonathan-Rao/rdk-blog-dist/edit/master/docs/_posts/前端/初级前端快速转TypeScript指南.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=%E5%AD%A6%E4%B9%A0" title="标签">#学习</a><a href="/tags/?tag=%E7%9F%A5%E8%AF%86" title="标签">#知识</a><a href="/tags/?tag=TypeScript" title="标签">#TypeScript</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/01/13, 8:01:00</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/eabcb8/"><div>
            前端工程师生产环境 debugger 技巧
            <!----></div></a> <span class="date">10-17</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/2dd8e1/"><div>
            独立开发者资源
            <!----></div></a> <span class="date">09-05</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/1bf551/"><div>
            Vis-Network中文API文档
            <!----></div></a> <span class="date">09-29</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:515977826@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/Jonathan-Rao" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2025
    <span>DK Rao | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.63f7405e.js" defer></script><script src="/assets/js/3.4c003ae3.js" defer></script><script src="/assets/js/2.1e9afdb9.js" defer></script><script src="/assets/js/70.fdb34293.js" defer></script>
  </body>
</html>
